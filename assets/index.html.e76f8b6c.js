import{r as e,o as r,c as a,a as l,F as t,b as i,d as n}from"./app.cac75193.js";const o={},h=l("h2",{id:"介绍",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#介绍","aria-hidden":"true"},"#"),i(" 介绍")],-1),d=i("面向现代浏览器的一个更轻、更快的Web应用开发工具，基于ECMAScript 标准原生模块系统（ES Modules）实现。相对于 "),p={href:"https://cli.vuejs.org/zh/",target:"_blank",rel:"noopener noreferrer"},s=i("Vue CLI"),c=i(" 、"),u={href:"https://webpack.docschina.org/",target:"_blank",rel:"noopener noreferrer"},b=i("webpack"),f=i("更快。"),M=n('<h2 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h2><ol><li><p>轻量</p></li><li><p>按需打包</p></li></ol><p>Vite 以 原生 ESM 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。</p><ol start="3"><li>HMR (热渲染依赖）</li></ol><p>在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活（大多数时候只是模块本身），使得无论应用大小如何，HMR 始终能保持快速更新。</p><p>Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。</p><ul><li><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2></li></ul>',7),k={href:"https://cn.vitejs.dev/",target:"_blank",rel:"noopener noreferrer"},V=i("Vite");o.render=function(i,n){const o=e("OutboundLink");return r(),a(t,null,[h,l("blockquote",null,[l("p",null,[d,l("a",p,[s,l(o)]),c,l("a",u,[b,l(o)]),f])]),M,l("ul",null,[l("li",null,[l("a",k,[V,l(o)])])])],64)};export default o;
