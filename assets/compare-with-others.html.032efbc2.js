import{r as e,o as a,c as r,a as t,F as d,d as s,b as n}from"./app.cac75193.js";const i={},c=s('<p>当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。大型项目包含数千个模块的情况并不少见。我们开始遇到性能瓶颈 —— 使用 JavaScript 开发的工具通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用 HMR，文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的<strong>开发效率</strong>和<strong>幸福感</strong>。</p><h2 id="webpack-原理图" tabindex="-1"><a class="header-anchor" href="#webpack-原理图" aria-hidden="true">#</a> webpack 原理图</h2><p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" alt=""></p><h2 id="vite原理图" tabindex="-1"><a class="header-anchor" href="#vite原理图" aria-hidden="true">#</a> Vite原理图</h2><p><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" alt=""></p><h2 id="开发阶段比较" tabindex="-1"><a class="header-anchor" href="#开发阶段比较" aria-hidden="true">#</a> 开发阶段比较</h2><p>通过原理图可以看出 <code>webpack dev server</code> 在启动时需要先<code>build</code>一遍，而这个过程需要消耗很多时间。而vite 不同的是 执行<code>vite serve</code> 时，内部直接启动了<code>web Server</code>, 并不会先编译所有的代码文件,请求哪个模块再对该模块进行实时编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite的优势越明显。</p><h2 id="生产阶段比较" tabindex="-1"><a class="header-anchor" href="#生产阶段比较" aria-hidden="true">#</a> 生产阶段比较</h2><p>在构建这块，Vite 在开发服务器与产品最终构建结果没有 Webpack 一致性强。</p>',9),h=n("主要原因是我们为了在生产环境获得最佳的加载性能和兼容性，还是需要将代码进行tree-shaking、懒加载和 chunk 分割（以获得更好的缓存），所以 Vite 还是基于 "),o={href:"https://rollupjs.org/",target:"_blank",rel:"noopener noreferrer"},p=n("Rollup"),l=n(" 进行产品最终构建打包。"),u=t("h2",{id:"总结",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#"),n(" 总结")],-1),b=t("p",null,"在开发阶段vite的优势更为明显，而在生产构建阶段并没有特别突出的表现。",-1);i.render=function(s,n){const i=e("OutboundLink");return a(),r(d,null,[c,t("p",null,[h,t("a",o,[p,t(i)]),l]),u,b],64)};export default i;
